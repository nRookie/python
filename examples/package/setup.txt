New and Changed setup() Keywords


The following keywords arguments to setup() are added or changed 
by setuptools. All of them are optional; you do not have supply 
them unless you need the associated setuptools feature.


include_package_data
    if set to True, this tells setuptools to automatically include any data files 
it finds inside your package directories that are specified by your MANIFEST.in file.
For more information, see the section below to including Data Files.

exclude_package_data
    A dictionary mapping package names to list of glob patterns that should be 
excluded from your package directories. You can use this trim back 
any excess files included by include_package_data. For a complete description and 
examples, see the section below on Including Data Files .


package_data 
    A dictionary mapping package names to lists of glob patterns. For  a complete description 
    and examples, see the section below on Including Data Files. You do not need to use this option 
    if you are using include_package_data, unless you need to add e.g. files that are 
    generated by your setup script and build process. (And are therefore not in source control or 
    are files that you don't want to include in your source distribution.)

zip_safe
    A boolean(True or False) flag specifying whether the project can be safely installed and run from a 
    zip file. If this argument is not supplied, the bdist_egg command will have to analyze all of your project's contents 
    for possible problems each time it builds an egg.

install_requires
    A string or list of strings specifying what other distributions need to be installed when this one is .
    See the section below on Declaring Dependencies for details and examples of the format of this argument.


entry_points
    A dictionary mapping entry point group names to strings or lists of strings defining and entry points.
    Entry points are used to support dynamic discovery of services or plugins 
    provided by a project. See Dynamic Discovery of Service and Plugins for details and examples of the format of this argument.
    In addition, this keyword is used to support Automatic Script Creation.


extras_require
    A dictionary mapping names of "extras"(optional features of your project) to strings or lists of strings specifying 
    what other distribution must be installed to support those features. See the section below on 
    Declaring Dependencies for details and examples of the format of this argument.


python_requires
    A string corresponding to version specifier (as defined in PEP 440) for the 
    Python version, used to specify the Requires-Python defined in PEP 345.


setup_requires
    A string or list of strings specifying what other distributions need to be present in order of the 
    setup script to run. setuptools will attempt to obtain these (even going so far 
    as to download them using EasyInstall) before processing the rest of the 
    setup script or commands. This argument is needed if you are using distutils extensions 
    as part of your build process; for example, extensions that process setup() arguments and turn them into 
    EGG-INFO metadata file.
    (Note: projects listed in setup_requires will NOT be automatically installed on 
    the system where the setup script being run. They are simply downloaded to the ./.eggs directory 
    if they're not locally available already. If you want them to be installed,
    as well as being available when the setup script is run, you should add them to 
    install_requires and setup_requires.)

dependency_links
    A list of strings naming URLs to be searched when satisfying dependencies. These links will be used if needed 
    to install packages specified by setup_requires or tests_requiere. They will also be written into the egg's metadata
for use by tools like EasyInstall to use when installing an .egg file.


namespace_packages 
    A list of strings naming the project's "namespace packages". A namespace package is a 
    package that may be split across multiple project distributions. For example,
Zope 3's zope package is a namespace package, because subpackages like zope.interface 
and zope.publisher may be distributed separately. The egg runtime system can automatically 
merge such subpackages into a single parent package at runtime,as long as 
the namespace package's __init__.py does not contain any code other than a namespace declaration.
See the section below on Namespace Packages for mor information .


test_suite
    A string naming a unittest.TestCase subclass(or a package or module containing one or 
    more of them, or a method of such a subclass), or naming a function that can be called with no arguments and 
    returns a unittest.TestSuite.If the named suite is a module, and the module has an additional_tests() function,
    it is called and the results are added to the tests to be run. If the named suite is a package,
    any submodules and subpackages are recursively added to the overall test suite.

    Specifying this argument enables use of the test command to run the specified test suite,e.g. via setup.py test.
    See the section on the test command below for more details.


Including Data Files 

The distutils have traditionally allowed installation of "data files",
which are placed in platform-specific location.
However, the most common use case for data files distributed with a package is for use by the package,
usually by including data files in the package directory.

Setuptools offers three ways to specify data files to be included in your packages.
First, you can simply use the include_package_data keyword, e.g.:

from setuptools import setup,find_packages
setup(
    ...
    include_package_Data=True
)

This tells setuptools to install any data files it finds in your packages . The data files must be specified via the distutils'
MANIFEST.in file.(They can also be tracked by a revision control system, using an appropriate plugin.
See the section below on Adding Support for Revision Control Systems for information on 
how to write such plugins.)


If you want finer-grained control over what files are included(for example, if you have documentation files 
in your package directories and want to exclude them from installation)
,then you can also use the package_data keyword.
e.g.:

from setuptools import setup,find_packages
setup(
    ...
    package_data={
        # If any package contains *.txt or *.rst files, include them:
        '':['*.txt','*.rst'],
        # And include any *.msg files found in the 'hello' package, too:
        'hello':['*.msg'],
    }
)

The package_data argument is a dictionary maps from package names to lists of glob patterns.
The globs may include subdirectory names, if the data files are contained in a subdirectory 
of the package. For example, if the package tree looks like this:

setup.py 
src/
    mypkg/
        __init__.py
        mypkg.txt
        data/
            somefile.data
            otherdata.dat 

The setuptools setup file might look like this:

from setuptools import setup,find_packages
setup(
    ...
    packages=find_packages('src'),
    package_dir={'':'src'},

    package_data={
        # If any package contains *.txt files, include them;
        '':['*.txt'],
        # And include any *.dat files found in the 'data' subdirectory 
        # of the 'mypkg' package, also:
        'mypkg': ['data/*.dat'],
    }
)

Notice that if you list patterns patterns in package_data under the 
empty string, these patterns are used to find files in every package,
even one that also have their own patterns listed. Thus, in the above example, the mypkg.txt file 
gets included even though it's not listed in the paterns for mypkg.

Also notice that if you use paths, you must use a forward slash(/)
as the path separator, even if you are on Windows, Setuptools automatically 
converts slashes to appropriate platform-specific separators at build time .

If datafiles are contained in a sbudirectory of a package that isn't a 
package itself(no __init__.py), then the subdirectory names(or*) are 
required in the package_data argument( as shown above with 'data/*.dat').

When building an sdist, the datafiles are also drawn from the package_name.egg-info/SOURCES.txt file,
so make sure that this is removed if the setup.py package_Data list is updated before 
calling setup.py.

(Note:although the package_data argument was previously only available in setuptools, it was also added to the Python 
distutils package as of Python 2.4; there is some documentation for the feature available on the python.org website.
If using the setuptools-specific include_package_data argument,files specified by package_Data will not be automatically added to the 
manifest unless they are listed in the MANIFEST.in file.)

Sometimes,the include_package_Data or package_data options alone aren't sufficient to 
precisely define what files you want included. For example , you may want to include 
package README files in your revision control system and source distributions,
but exclude them from being installed. So,setuptools offers an exclude package data option 
as well that allows you to do things like this:

from setuptools import setup,find_packages
setup(
    ...
    packages=find_packages('src'), # include all packages under src 
    package_dir={'':'src'}, # tell distutils packages are under src 

    include_package_data=True,  # include everything in source control 

    # ... but exclude README.txt from all packages 
    exclude_package_data={'':['README.txt']},
)


The exclude_package_data option is a directory mapping package names to lists of wildcard 
patterns, just like the package_data option. And, just as with that option,
a key of '' will apply the given pattern(s) to all packages. However ,
any files that match these patterns will be excluded from installation,even if they were 
listed in package_Data or were included as a result of using include_package_data.

In summary, the three options allows you to do things like this

from setuptools import setup, find_packages 
setup(

)

:


Using find_packages()

For simple projects, it's usually easy enough to manually add packages to the packages argument of 
setup(). However, for very large projects(Twisted,PEAK,Zope,Chandler,etc.),
it can be a big burden to keep the package list updated. That's what setuptools.find_packages() is for.

find_packages() takes a source directory and two lists of package name patterns to exclude and include . If omitted, 
the source directory defaults to the same directory as the setup script.
Some projects use a src or lib directory as the root of their source tree,
and those projects would of course use "src" or "lib" as the first argument to find_packages().
(And such projects also need something like package_dir={'':'src'}) in their setup()
arguments, but that's just a normal distutils thing.)

